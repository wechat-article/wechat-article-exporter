# Todos

## 统一管理与存储接口的 cookie 数据

所有 cookie (除 uuid 外)不再传递给浏览器，统一在后端存储。后端在转发微信接口时，从浏览器传递过来的 uuid 去检索出对应的 cookie，并设置到请求中。

uuid 这个唯一的 cookie 支持通过 cookie 传输，也支持放在 Authorization 中传输，这样既可以支持网站自动携带 uuid，也支持 API 手动添加 uuid，效果一样。

这样重构之后，应该可以把登录和 API 授权统一起来，登录即授权。

为了信息安全，不仅仅需要 uuid，还需要进行签名验证。


## 增加并显示网站版本

版本号可以是最新发版的日期(比如: `20250910.1`)，并在网站 logo附近 显示。

该版本号也将作为存储的数据结构的版本号，当有不兼容的升级时，前端在处理localStorage数据时可据此进行数据迁移。

后期会增加订阅与消息通知(webhook)，需要存储一些密钥什么的，并且会有cron任务，这些任务必须在服务器上执行，所以这些密钥需要存储在服务器端。

网站的设置信息还是保留在浏览器端，需要做好版本不兼容时的数据迁移(根据添加的版本号进行)。


## 如何做收费项目

docker本地化部署 99
包含的功能：
专业版网站所具有的一切功能(不含收费项目)。

收费项目：订阅制，10元/月 100/年
- 多公众号一键抓取
- 下载页面公众号多选
- 多公众号免扫码切换(需同一个微信关联多个公众号)
- 公众号订阅(每人限50个公众号)
- API ？
- 导出格式 pdf? word?


## 签名验证

网站提供 RSA 方式的签名与验证，所有需要检索 cookie 的请求都需要有签名参数。

签名的验证逻辑为：
请求中携带 uuid，另外加上 timestamp + nonce + sign

`timestamp`即客户端请求时的系统时间，`nonce`为随机生成的随机字符串，据此`sign`的生成逻辑为：rsa.sign(uuid + timestamp + nonce)

服务器需要验证客户端传递的 sign 参数。

rsa 的公钥需要上传到服务器，私钥留在浏览器本地。

这样就可以避免服务器中的 cookie 仓库被暴力扫描，每个人只能获取到自己的 cookie 数据。


## 接口归类

对第三方开放的接口位于`server/api/public`目录下，网站自用的接口位于`server/api/web`目录下。

其中，自用的接口又分为登录、公众号后台查询、非公众号后台接口，分别位于不同的目录。

- 登录相关接口位于`login`子目录，需要携带 uuid 这个 cookie
- 公众号后台查询接口位于`mp`子目录，需要从 CookieStore 中查询相关 cookie 并透传给微信
- 非公众号后台接口位于`misc`子目录，不需要从 CookieStore 检索 cookie


## 订阅

订阅按照订阅源来进行管理，每一个订阅源对应一个同步策略(cron)。
订阅源也可以配置推送规则，比如各种群机器人、rsshub、邮件等。

一个订阅源可以添加多个公众号，这些公众号都按照订阅源的cron进行同步。

订阅源相当于一个任务队列，里面的每个公众号相当于一个任务，任务是顺序执行的，一个任务执行完才能执行下一个任务。
因此，需要定义任务执行间隔，或者该值固定但可配置。

### cron 的实现
采用 kv 存储每个订阅源的配置，使用 nitro 原生的 [Scheduled tasks](https://nitro.build/guide/tasks#scheduled-tasks) 每分钟读取 kv 配置，并检查是否需要执行 task 任务。

## 公众号可以批量导入导出，并且做一个精选公众号列表，可以快速添加高质量的公众号到列表中，不用再一个个的搜索添加了。

## 推送配置

邮件
钉钉机器人
webhook
